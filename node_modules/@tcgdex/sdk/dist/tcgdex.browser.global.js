"use strict";
var TCGdex = (() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
  var __async = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      };
      var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };

  // src/tcgdex.browser.ts
  var tcgdex_browser_exports = {};
  __export(tcgdex_browser_exports, {
    default: () => tcgdex_browser_default
  });

  // node_modules/unfetch/dist/unfetch.module.js
  function unfetch_module_default(e, n) {
    return n = n || {}, new Promise(function(t, r) {
      var s = new XMLHttpRequest(), o = [], u = [], i = {}, a = function() {
        return { ok: 2 == (s.status / 100 | 0), statusText: s.statusText, status: s.status, url: s.responseURL, text: function() {
          return Promise.resolve(s.responseText);
        }, json: function() {
          return Promise.resolve(s.responseText).then(JSON.parse);
        }, blob: function() {
          return Promise.resolve(new Blob([s.response]));
        }, clone: a, headers: { keys: function() {
          return o;
        }, entries: function() {
          return u;
        }, get: function(e2) {
          return i[e2.toLowerCase()];
        }, has: function(e2) {
          return e2.toLowerCase() in i;
        } } };
      };
      for (var l in s.open(n.method || "get", e, true), s.onload = function() {
        s.getAllResponseHeaders().replace(/^(.*?):[^\S\n]*([\s\S]*?)$/gm, function(e2, n2, t2) {
          o.push(n2 = n2.toLowerCase()), u.push([n2, t2]), i[n2] = i[n2] ? i[n2] + "," + t2 : t2;
        }), t(a());
      }, s.onerror = r, s.withCredentials = "include" == n.credentials, n.headers)
        s.setRequestHeader(l, n.headers[l]);
      s.send(n.body || null);
    });
  }

  // src/version.js
  var version = "2.5.1";

  // src/Request.ts
  var Request = class {
    static fetch(url) {
      return __async(this, null, function* () {
        let request = this.cache[url];
        const now = (/* @__PURE__ */ new Date()).getTime();
        if (!request || now - request.time > this.ttl) {
          const unfetch = TCGdex.fetch;
          const resp = yield unfetch(url, {
            headers: {
              "user-agent": `@tcgdex/javascript-sdk/${version}`
            }
          });
          if (resp.status !== 200) {
            return void 0;
          }
          this.cache[url] = { response: yield resp.json(), time: now };
          request = this.cache[url];
        }
        return request.response;
      });
    }
  };
  // 1 hour of TTL by default
  Request.ttl = 1e3 * 60 * 60;
  Request.cache = {};

  // src/tcgdex.ts
  var ENDPOINTS = ["cards", "categories", "dex-ids", "energy-types", "hp", "illustrators", "rarities", "regulation-marks", "retreats", "series", "sets", "stages", "suffixes", "trainer-types", "types", "variants"];
  var BASE_URL = "https://api.tcgdex.net/v2";
  var _TCGdex = class _TCGdex {
    constructor(lang) {
      this.lang = lang;
    }
    getLang() {
      var _a2, _b;
      return (_b = (_a2 = this.lang) != null ? _a2 : _TCGdex.defaultLang) != null ? _b : "en";
    }
    /**
     * Shortcut to easily fetch a card using both it's global id and it's local ID
     * @param id the card global/local ID
     * @param set the card set name/ID (optionnal)
     * @returns the card object
     */
    fetchCard(id, set) {
      return __async(this, null, function* () {
        const path = set ? ["sets", set] : ["cards"];
        return this.fetch(...path, id);
      });
    }
    /**
     * Shortcut to easily fetch cards using an optionnal set name/ID
     * @param set the card set name/ID (optionnal)
     * @returns a card list
     */
    fetchCards(set) {
      return __async(this, null, function* () {
        if (set) {
          const fSet = yield this.fetch("sets", set);
          return fSet ? fSet.cards : void 0;
        }
        return this.fetch("cards");
      });
    }
    /**
     * @deprecated use `this.fetch('sets', set)`
     */
    fetchSet(set) {
      return __async(this, null, function* () {
        return this.fetch("sets", set);
      });
    }
    /**
     * @deprecated use `this.fetch('series', serie)`
     */
    fetchSerie(serie) {
      return __async(this, null, function* () {
        return this.fetch("series", serie);
      });
    }
    /**
     * @deprecated use `this.fetch('series')`
     */
    fetchSeries() {
      return __async(this, null, function* () {
        return this.fetch("series");
      });
    }
    /**
     * Shortcut to easily fetch sets using an optionnal serie name/ID
     * @param serie the card set name/ID (optionnal)
     * @returns a card list
     */
    fetchSets(serie) {
      return __async(this, null, function* () {
        if (serie) {
          const fSerie = yield this.fetch("series", serie);
          return fSerie ? fSerie.sets : void 0;
        }
        return this.fetch("sets");
      });
    }
    /**
     * Fetch The differents endpoints depending on the first argument
     * @param endpoint_0 {'hp' | 'retreats' | 'categories' | 'illustrators' | 'rarities' | 'types'}
     * Possible value 'cards' | 'categories' | 'hp' | 'illustrators' | 'rarities' | 'retreats' | 'series' | 'sets' | 'types'
     * @param endpoint_1 {string} (Optionnal) some details to go from the index file to the item file (mostly the ID/name)
     * @param endpoint_2 {string} (Optionnal) only for sets the card local ID to fetch the card through the set
     */
    fetch(...endpoint) {
      return __async(this, null, function* () {
        if (endpoint.length === 0) {
          throw new Error("endpoint to fetch is empty!");
        }
        const baseEndpoint = endpoint.shift().toLowerCase();
        if (!ENDPOINTS.includes(baseEndpoint)) {
          throw new Error(`unknown endpoint to fetch! (${baseEndpoint})`);
        }
        return this.makeRequest(baseEndpoint, ...endpoint);
      });
    }
    /**
     * Function to make the request and normalize the whole path
     */
    makeRequest(...url) {
      const path = url.map((subPath) => encodeURI(
        subPath.toString().replace("?", "%3F").normalize("NFC").replace(/["'\u0300-\u036f]/gu, "")
      )).join("/");
      return Request.fetch(`${BASE_URL}/${this.getLang()}/${path}`);
    }
  };
  /**
   * @deprecated to change the lang use `this.lang`
   */
  _TCGdex.defaultLang = "en";
  var TCGdex = _TCGdex;

  // src/tcgdex.browser.ts
  var _a;
  TCGdex.fetch = (_a = window.fetch) != null ? _a : unfetch_module_default;
  var tcgdex_browser_default = TCGdex;
  return __toCommonJS(tcgdex_browser_exports);
})();
//# sourceMappingURL=tcgdex.browser.global.js.map