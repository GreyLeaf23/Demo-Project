"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/tcgdex.node.ts
var tcgdex_node_exports = {};
__export(tcgdex_node_exports, {
  default: () => tcgdex_node_default
});
module.exports = __toCommonJS(tcgdex_node_exports);

// src/version.js
var version = "2.5.1";

// src/Request.ts
var Request = class {
  static fetch(url) {
    return __async(this, null, function* () {
      let request = this.cache[url];
      const now = (/* @__PURE__ */ new Date()).getTime();
      if (!request || now - request.time > this.ttl) {
        const unfetch = TCGdex.fetch;
        const resp = yield unfetch(url, {
          headers: {
            "user-agent": `@tcgdex/javascript-sdk/${version}`
          }
        });
        if (resp.status !== 200) {
          return void 0;
        }
        this.cache[url] = { response: yield resp.json(), time: now };
        request = this.cache[url];
      }
      return request.response;
    });
  }
};
// 1 hour of TTL by default
Request.ttl = 1e3 * 60 * 60;
Request.cache = {};

// src/tcgdex.ts
var ENDPOINTS = ["cards", "categories", "dex-ids", "energy-types", "hp", "illustrators", "rarities", "regulation-marks", "retreats", "series", "sets", "stages", "suffixes", "trainer-types", "types", "variants"];
var BASE_URL = "https://api.tcgdex.net/v2";
var _TCGdex = class _TCGdex {
  constructor(lang) {
    this.lang = lang;
  }
  getLang() {
    var _a, _b;
    return (_b = (_a = this.lang) != null ? _a : _TCGdex.defaultLang) != null ? _b : "en";
  }
  /**
   * Shortcut to easily fetch a card using both it's global id and it's local ID
   * @param id the card global/local ID
   * @param set the card set name/ID (optionnal)
   * @returns the card object
   */
  fetchCard(id, set) {
    return __async(this, null, function* () {
      const path = set ? ["sets", set] : ["cards"];
      return this.fetch(...path, id);
    });
  }
  /**
   * Shortcut to easily fetch cards using an optionnal set name/ID
   * @param set the card set name/ID (optionnal)
   * @returns a card list
   */
  fetchCards(set) {
    return __async(this, null, function* () {
      if (set) {
        const fSet = yield this.fetch("sets", set);
        return fSet ? fSet.cards : void 0;
      }
      return this.fetch("cards");
    });
  }
  /**
   * @deprecated use `this.fetch('sets', set)`
   */
  fetchSet(set) {
    return __async(this, null, function* () {
      return this.fetch("sets", set);
    });
  }
  /**
   * @deprecated use `this.fetch('series', serie)`
   */
  fetchSerie(serie) {
    return __async(this, null, function* () {
      return this.fetch("series", serie);
    });
  }
  /**
   * @deprecated use `this.fetch('series')`
   */
  fetchSeries() {
    return __async(this, null, function* () {
      return this.fetch("series");
    });
  }
  /**
   * Shortcut to easily fetch sets using an optionnal serie name/ID
   * @param serie the card set name/ID (optionnal)
   * @returns a card list
   */
  fetchSets(serie) {
    return __async(this, null, function* () {
      if (serie) {
        const fSerie = yield this.fetch("series", serie);
        return fSerie ? fSerie.sets : void 0;
      }
      return this.fetch("sets");
    });
  }
  /**
   * Fetch The differents endpoints depending on the first argument
   * @param endpoint_0 {'hp' | 'retreats' | 'categories' | 'illustrators' | 'rarities' | 'types'}
   * Possible value 'cards' | 'categories' | 'hp' | 'illustrators' | 'rarities' | 'retreats' | 'series' | 'sets' | 'types'
   * @param endpoint_1 {string} (Optionnal) some details to go from the index file to the item file (mostly the ID/name)
   * @param endpoint_2 {string} (Optionnal) only for sets the card local ID to fetch the card through the set
   */
  fetch(...endpoint) {
    return __async(this, null, function* () {
      if (endpoint.length === 0) {
        throw new Error("endpoint to fetch is empty!");
      }
      const baseEndpoint = endpoint.shift().toLowerCase();
      if (!ENDPOINTS.includes(baseEndpoint)) {
        throw new Error(`unknown endpoint to fetch! (${baseEndpoint})`);
      }
      return this.makeRequest(baseEndpoint, ...endpoint);
    });
  }
  /**
   * Function to make the request and normalize the whole path
   */
  makeRequest(...url) {
    const path = url.map((subPath) => encodeURI(
      subPath.toString().replace("?", "%3F").normalize("NFC").replace(/["'\u0300-\u036f]/gu, "")
    )).join("/");
    return Request.fetch(`${BASE_URL}/${this.getLang()}/${path}`);
  }
};
/**
 * @deprecated to change the lang use `this.lang`
 */
_TCGdex.defaultLang = "en";
var TCGdex = _TCGdex;

// src/tcgdex.node.ts
var import_isomorphic_unfetch = __toESM(require("isomorphic-unfetch"));
TCGdex.fetch = import_isomorphic_unfetch.default;
var tcgdex_node_default = TCGdex;
