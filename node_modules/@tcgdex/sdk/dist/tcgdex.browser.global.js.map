{"version":3,"sources":["../src/tcgdex.browser.ts","../node_modules/unfetch/src/index.mjs","../src/version.js","../src/Request.ts","../src/tcgdex.ts"],"sourcesContent":["import unfetch from 'unfetch'\nimport TCGdex from './tcgdex'\n\nTCGdex.fetch = window.fetch ?? unfetch as any\n\nexport default TCGdex\n","export default function(url, options) {\n\toptions = options || {};\n\treturn new Promise( (resolve, reject) => {\n\t\tconst request = new XMLHttpRequest();\n\t\tconst keys = [];\n\t\tconst all = [];\n\t\tconst headers = {};\n\n\t\tconst response = () => ({\n\t\t\tok: (request.status/100|0) == 2,\t\t// 200-299\n\t\t\tstatusText: request.statusText,\n\t\t\tstatus: request.status,\n\t\t\turl: request.responseURL,\n\t\t\ttext: () => Promise.resolve(request.responseText),\n\t\t\tjson: () => Promise.resolve(request.responseText).then(JSON.parse),\n\t\t\tblob: () => Promise.resolve(new Blob([request.response])),\n\t\t\tclone: response,\n\t\t\theaders: {\n\t\t\t\tkeys: () => keys,\n\t\t\t\tentries: () => all,\n\t\t\t\tget: n => headers[n.toLowerCase()],\n\t\t\t\thas: n => n.toLowerCase() in headers\n\t\t\t}\n\t\t});\n\n\t\trequest.open(options.method || 'get', url, true);\n\n\t\trequest.onload = () => {\n\t\t\trequest.getAllResponseHeaders().replace(/^(.*?):[^\\S\\n]*([\\s\\S]*?)$/gm, (m, key, value) => {\n\t\t\t\tkeys.push(key = key.toLowerCase());\n\t\t\t\tall.push([key, value]);\n\t\t\t\theaders[key] = headers[key] ? `${headers[key]},${value}` : value;\n\t\t\t});\n\t\t\tresolve(response());\n\t\t};\n\n\t\trequest.onerror = reject;\n\n\t\trequest.withCredentials = options.credentials=='include';\n\n\t\tfor (const i in options.headers) {\n\t\t\trequest.setRequestHeader(i, options.headers[i]);\n\t\t}\n\n\t\trequest.send(options.body || null);\n\t});\n}\n","export const version = '2.5.1'","import TCGdex from './tcgdex'\nimport { version } from './version'\n\nexport default class Request {\n\n\t// 1 hour of TTL by default\n\tpublic static ttl = 1000 * 60 * 60\n\n\tprivate static cache: Record<string, {response: any, time: number}> = {}\n\n\tpublic static async fetch<T>(url: string): Promise<T | undefined> {\n\t\tlet request = this.cache[url]\n\t\tconst now = new Date().getTime()\n\t\tif (!request || now - request.time > this.ttl) {\n\t\t\tconst unfetch = TCGdex.fetch\n\t\t\tconst resp = await unfetch(url, {\n\t\t\t\theaders: {\n\t\t\t\t\t'user-agent': `@tcgdex/javascript-sdk/${version}`\n\t\t\t\t}\n\t\t\t})\n\t\t\tif (resp.status !== 200) {\n\t\t\t\treturn undefined\n\t\t\t}\n\n\t\t\tthis.cache[url] = { response: await resp.json(), time: now }\n\t\t\trequest = this.cache[url]\n\t\t}\n\t\treturn request.response\n\t}\n\n}\n","import RequestWrapper from './Request'\nimport { Serie, Set, Card, CardResume, SerieList, SetList, SupportedLanguages, StringEndpoint } from './interfaces'\ntype Endpoint = 'cards' | 'categories' | 'dex-ids' | 'energy-types' | 'hp' | 'illustrators' | 'rarities' | 'regulation-marks' | 'retreats' | 'series' | 'sets' | 'stages' | 'suffixes' | 'trainer-types' | 'types' | 'variants'\n\nconst ENDPOINTS: Array<Endpoint> = ['cards', 'categories', 'dex-ids', 'energy-types', 'hp', 'illustrators', 'rarities', 'regulation-marks', 'retreats', 'series', 'sets', 'stages', 'suffixes', 'trainer-types', 'types', 'variants']\nconst BASE_URL = 'https://api.tcgdex.net/v2'\nexport default class TCGdex {\n\n\tpublic static fetch: typeof fetch\n\n\t/**\n\t * @deprecated to change the lang use `this.lang`\n\t */\n\tpublic static defaultLang: SupportedLanguages = 'en'\n\n\tpublic constructor(public lang?: SupportedLanguages) {}\n\n\tpublic getLang(): SupportedLanguages {\n\t\treturn this.lang ?? TCGdex.defaultLang ?? 'en'\n\t}\n\n\t/**\n\t * Shortcut to easily fetch a card using both it's global id and it's local ID\n\t * @param id the card global/local ID\n\t * @param set the card set name/ID (optionnal)\n\t * @returns the card object\n\t */\n\tpublic async fetchCard(id: string | number, set?: string): Promise<Card | undefined> {\n\t\tconst path = set ? ['sets', set] : ['cards']\n\t\t// @ts-expect-error the base endpoint is 'sets' or 'cards'\n\t\treturn this.fetch(...path, id)\n\t}\n\n\t/**\n\t * Shortcut to easily fetch cards using an optionnal set name/ID\n\t * @param set the card set name/ID (optionnal)\n\t * @returns a card list\n\t */\n\tpublic async fetchCards(set?: string): Promise<Array<CardResume> | undefined> {\n\t\tif (set) {\n\t\t\tconst fSet = await this.fetch('sets', set)\n\t\t\treturn fSet ? fSet.cards : undefined\n\t\t}\n\t\treturn this.fetch('cards')\n\t}\n\n\t/**\n\t * @deprecated use `this.fetch('sets', set)`\n\t */\n\tpublic async fetchSet(set: string): Promise<Set | undefined> {\n\t\treturn this.fetch('sets', set)\n\t}\n\n\t/**\n\t * @deprecated use `this.fetch('series', serie)`\n\t */\n\tpublic async fetchSerie(serie: string): Promise<Serie | undefined> {\n\t\treturn this.fetch('series', serie)\n\t}\n\n\t/**\n\t * @deprecated use `this.fetch('series')`\n\t */\n\tpublic async fetchSeries(): Promise<SerieList | undefined> {\n\t\treturn this.fetch('series')\n\t}\n\n\t/**\n\t * Shortcut to easily fetch sets using an optionnal serie name/ID\n\t * @param serie the card set name/ID (optionnal)\n\t * @returns a card list\n\t */\n\tpublic async fetchSets(serie?: string): Promise<SetList | undefined> {\n\t\tif (serie) {\n\t\t\tconst fSerie = await this.fetch('series', serie)\n\t\t\treturn fSerie ? fSerie.sets : undefined\n\t\t}\n\t\treturn this.fetch('sets')\n\t}\n\n\t/**\n\t * Fetch a card using its global id\n\t * @param endpoint_0 'cards'\n\t * @param endpoint_1 {string} the card global ID\n\t */\n\tpublic async fetch(...type: ['cards', string]): Promise<Card | undefined>\n\n\t/**\n\t * Fetch every cards in the database\n\t * @param endpoint_0 'cards'\n\t */\n\tpublic async fetch(type: 'cards'): Promise<Array<CardResume> | undefined>\n\n\t/**\n\t * Fetch a card using its local id and its set\n\t * @param endpoint_0 'sets'\n\t * @param endpoint_1 {string} the set name or ID\n\t * @param endpoint_2 {string} the card local ID\n\t */\n\tpublic async fetch(...endpoint: ['sets', string, string]): Promise<Card | undefined>\n\n\t/**\n\t * Fetch a set\n\t * @param endpoint_0 'sets'\n\t * @param endpoint_1 {string} the set name or ID\n\t */\n\tpublic async fetch(...endpoint: ['sets', string]): Promise<Set | undefined>\n\n\t/**\n\t * Fetch every sets\n\t * @param endpoint_0 'sets'\n\t */\n\tpublic async fetch(endpoint: 'sets'): Promise<SetList | undefined>\n\n\t/**\n\t * Fetch a serie\n\t * @param endpoint_0 'series'\n\t * @param endpoint_1 {string} the serie name or ID\n\t */\n\tpublic async fetch(...endpoint: ['series', string]): Promise<Serie | undefined>\n\n\t/**\n\t * Fetch every series\n\t * @param endpoint_0 'series'\n\t */\n\tpublic async fetch(endpoint: 'series'): Promise<SerieList | undefined>\n\n\t/**\n\t * Fetch cards depending on a specific filter\n\t * @param endpoint_0 {'categories' | 'dex-ids' | 'energy-types' | 'hp' | 'illustrators' | 'rarities' | 'regulation-marks' | 'retreats' | 'stages' | 'suffixes' | 'trainer-types' | 'types' | 'variants'}\n\t * Possible value 'categories' | 'dex-ids' | 'energy-types' | 'hp' | 'illustrators' | 'rarities' | 'regulation-marks' | 'retreats' | 'stages' | 'suffixes' | 'trainer-types' | 'types' | 'variants'\n\t * @param endpoint_1 {string} the value set while fetching the index\n\t */\n\tpublic async fetch(...endpoint: ['categories' | 'dex-ids' | 'energy-types' | 'hp' | 'illustrators' | 'rarities' | 'regulation-marks' | 'retreats' | 'stages' | 'suffixes' | 'trainer-types' | 'types' | 'variants', string]): Promise<StringEndpoint | undefined>\n\n\t/**\n\t * Fetch cards depending on a specific filter\n\t * @param endpoint_0 {'categories' | 'dex-ids' | 'energy-types' | 'hp' | 'illustrators' | 'rarities' | 'regulation-marks' | 'retreats' | 'stages' | 'suffixes' | 'trainer-types' | 'types' | 'variants'}\n\t * Possible value 'categories' | 'dex-ids' | 'energy-types' | 'hp' | 'illustrators' | 'rarities' | 'regulation-marks' | 'retreats' | 'stages' | 'suffixes' | 'trainer-types' | 'types' | 'variants'\n\t * @param endpoint_1 {string} Fetch the possible values to use depending on the endpoint\n\t */\n\tpublic async fetch(endpoint: 'categories' | 'dex-ids' | 'energy-types' | 'hp' | 'illustrators' | 'rarities' | 'regulation-marks' | 'retreats' | 'stages' | 'suffixes' | 'trainer-types' | 'types' | 'variants'): Promise<Array<string> | undefined>\n\n\t/**\n\t * Fetch The differents endpoints depending on the first argument\n\t * @param endpoint_0 {'hp' | 'retreats' | 'categories' | 'illustrators' | 'rarities' | 'types'}\n\t * Possible value 'cards' | 'categories' | 'hp' | 'illustrators' | 'rarities' | 'retreats' | 'series' | 'sets' | 'types'\n\t * @param endpoint_1 {string} (Optionnal) some details to go from the index file to the item file (mostly the ID/name)\n\t * @param endpoint_2 {string} (Optionnal) only for sets the card local ID to fetch the card through the set\n\t */\n\tpublic async fetch(...endpoint: Array<Endpoint | string>): Promise<any | undefined> {\n\t\tif (endpoint.length === 0) {\n\t\t\tthrow new Error('endpoint to fetch is empty!')\n\t\t}\n\t\t// @ts-expect-error with the precedent check, we KNOW that type is not empty\n\t\tconst baseEndpoint = endpoint.shift().toLowerCase() as Endpoint\n\t\tif (!ENDPOINTS.includes(baseEndpoint)) {\n\t\t\tthrow new Error(`unknown endpoint to fetch! (${baseEndpoint})`)\n\t\t}\n\t\treturn this.makeRequest(baseEndpoint, ...endpoint)\n\t}\n\n\t/**\n\t * Function to make the request and normalize the whole path\n\t */\n\tprivate makeRequest<T = any>(...url: Array<string | number>) {\n\t\t// Normalize path\n\t\tconst path = url.map((subPath) => encodeURI(\n\t\t\tsubPath\n\t\t\t\t// Transform numbers to string\n\t\t\t\t.toString()\n\t\t\t\t// replace this special character with an escaped one\n\t\t\t\t.replace('?', '%3F')\n\t\t\t\t// normalize the string\n\t\t\t\t.normalize('NFC')\n\t\t\t\t// remove some special chars by nothing\n\t\t\t\t// eslint-disable-next-line no-misleading-character-class\n\t\t\t\t.replace(/[\"'\\u0300-\\u036f]/gu, '')\n\t\t)).join('/')\n\t\treturn RequestWrapper.fetch<T>(`${BASE_URL}/${this.getLang()}/${path}`)\n\t}\n\n}\n\nexport * from './interfaces'\n"],"mappings":"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","names":["url","options","Promise","resolve","reject","request","XMLHttpRequest","keys","all","headers","response","ok","status","statusText","responseURL","text","responseText","json","then","JSON","parse","blob","Blob","clone","entries","get","n","toLowerCase","has","i","open","method","onload","getAllResponseHeaders","replace","m","key","value","push","onerror","withCredentials","credentials","setRequestHeader","send","body","_a"]}